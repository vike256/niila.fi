---
layout: '/src/layouts/BaseLayout.astro'
title: 'Building an undetected computer vision aimbot'
date: '2024-07-28'
---

import { Image } from 'astro:assets';
import ow_img from '/src/images/python-colorbot-ow-ss.webp';
import val_img from '/src/images/python-colorbot-val-ss.webp';
import val_enemy_img from '/src/images/python-colorbot-enemy.jpg';
import hsv_img from '/src/images/python-colorbot-hsv.png';
import raze_img from '/src/images/python-colorbot-raze.jpeg';
import raze_mask_img from '/src/images/python-colorbot-raze-mask.jpg';
import raze_dilated_img from '/src/images/python-colorbot-raze-dilated.jpeg';
import raze_box_img from '/src/images/python-colorbot-raze-box.jpeg';
import raze_overlay_img from '/src/images/python-colorbot-raze-overlay.jpeg';

# {frontmatter.title}

Last year I was reminded of a <a href="https://unknowncheats.me/" target="_blank" rel="noopener noreferrer">forum</a> that discusses game hacking. I was browsing the VALORANT section for a while and came across some posts discussing "arduino cheats" and "colorbots". These were not terms I was familiar with and they peaked my interest.  

I saw videos of cheats that scanned the screen for enemies and moved the aim toward them with an Arduino that could send mouse input.  

Traditional aimbots work by first reading the enemy position from memory and then changing the player's viewangle, which also happens in memory. Reading from memory is much faster than scanning the screen, but it's way harder to do undetected.  

If you want to use an aimbot in VALORANT, you probably wouldn't want to do it through memory. So how to scan the screen for enemies?

<div class="note">
    <strong>NOTE:</strong>
    I do not condone cheating in any regard. This project was made as a hobby.
</div>

## Colorbots

So we're going to use AI to detect enemies, right? No, our solution will be much simpler and easier to understand.  

Here's some screenshots from two very popular FPS games, Overwatch and VALORANT:
<Image src={ow_img} alt="Overwatch screenshot" />  
<Image src={val_img} alt="VALORANT screenshot" />  
Notice that the enemies have red outlines? A computer can see those too! Computers are not colorblind (unlike me), so they have an easy time detecting colors from an image.  


The computer can see colors in many formats such as RGB, HSV and HSL. We'll use HSV which stands for *hue*, *saturation* and *value*.

<Image src={hsv_img} alt="HSV cylinder" /> 

What our goals are:
- Capture the screen
- Scan the image for targets
- Get the closest target
- Move our mouse toward the target

## Capture the screen

Capturing the screen is a core part of the program, but it's not necessary to understand how the colorbot works. All you need to know is that we can use a python library like <a href="https://pypi.org/project/mss/" target="_blank" rel="noopener noreferrer">MSS</a> to capture the screen at high framerates. Example <a href="https://github.com/vike256/tutorials/blob/main/colorbot/main.py" target="_blank" rel="noopener noreferrer">here</a>.

## Scan the image for targets

We wont just select the pixels on the image that are pure yellow since the outlines wont be just of one color value. We need to select a lower and and upper value for our color range that we look for. I wont go into how to find the perfect color range since there isn't one. We'll use one that works. If you want to experiement with finding the best color range look at <a href="https://github.com/vike256/Unibot/wiki/Finding-target-color-range" target="_blank" rel="noopener noreferrer">Unibot's wiki</a>. 

We shouldn't capture the whole screen, because it would aim at yellow UI elements and other useless stuff. Let's use a small image from the center of our screen. This is usually called the *FOV* of the cheat. The larger the FOV the larger the scanning area and we'll be aiming at enemies further away from the center of our screen. Use a smaller area for the sake of performance, and the fact that our aim is probably good enough to aim somewhere close the target.

Target image for testing:
<Image src={raze_img} alt="VALORANT raze" />  

Open the target image and convert it to HSV:
```py
import cv2
import numpy as np

# Select target image
img = cv2.imread('raze.jpeg')

# Convert image to HSV
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
```

Define the color range and create a mask:
```py
# Define the color range for masking (in HSV)
lower_color = np.array([20, 100, 100])
upper_color = np.array([30, 255, 255])

# Create mask based on color range
mask = cv2.inRange(hsv_img, lower_color, upper_color)
cv2.imwrite('raze-mask.jpeg', mask)
```

Here's what the raze-mask.jpeg looks like:
<Image src={raze_mask_img} alt="Image mask" />  

We found the right pixels, but we dont want to aim just at the outlines. We want to aim at the center of the target's head.

Dilate the pixels until it's just one shape:
```py
# Dilate the mask to expand the white areas and fill gaps
kernel = np.ones((3, 3), np.uint8)
dilated = cv2.dilate(mask, kernel, iterations=7)
cv2.imwrite('raze-dilated.jpeg', dilated)

# Convert the image to binary to make sure every pixel is either black or white
thresh = cv2.threshold(dilated, 60, 255, cv2.THRESH_BINARY)[1]
cv2.imwrite('raze-thresh.jpeg', thresh)
```

Here's the raze-dilated.jpeg:
<Image src={raze_dilated_img} alt="Mask dilated" />  

The raze-thresh.jpeg doesn't look any different. We just use the threshold function to make sure the image is pure black and white binary.

Find the contours in the image:
```py
# Find contours in the thresholded image
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
```

We have just one contour in our image, but let's loop through the contours. I'll draw boxes and the target aim position on the image.

```py
# Initialize the image we want to add boxes to
enemy_box = cv2.imread('raze-thresh.jpeg')

# Draw a box around every target
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)  # Get the bounding box coordinates
    enemy_box = cv2.rectangle(
                enemy_box,
                (x, y),
                (x + w, y + h),
                (0, 0, 255),  # Red color for the rectangle
                6  # Thickness of the rectangle
            )
    # Save a coordinate somewhere above the center of the box
    aim_pos = (
        x + w // 2,  # Horizontal center
        int(y + h * 0.2)  # Close to the top of the box
    )

# Draw the target position for our aim
enemy_box = cv2.circle(
    enemy_box,
    aim_pos,
    3,
    (0, 255, 0),  # Green color for the circle
    5
)

# Save the final image with the boxes and aim position
cv2.imwrite('raze-box.jpeg', enemy_box)
```

Here's what we have now:
<Image src={raze_box_img} alt="Overlay with boxes and target aim position" /> 

Overlay it on top of the original image and it looks like this:
<Image src={raze_overlay_img} alt="Overlay with boxes and target aim position" /> 

## Moving the mouse toward the target

This is quite a simple task since we have the position of the enemy on our screen. Now we just have to calculate how much to move our mouse to the left and right and use a command similar to this:
```py
mouse.move(aim_x, aim_y)
```

But in a game with anti-cheat, it's not that simple of a task. 

### Hardware cheats

To send mouse input without a kernel anti-cheat noticing, we'll have to send the input from an external device. We need hardware that can act as a mouse. You can use a single-board microcontroller with HID capabilities like the Arduino Leonardo or any of the Raspberry Pi Pico boards. I'll use the Pico W as an example since it was the board that I made <a href="https://github.com/vike256/RaspberryPiPicoW-Colorbot" target="_blank" rel="noopener noreferrer">my first hardware project</a> with.

## Sources 
<a href="https://www.reddit.com/r/borderlands3/comments/1d09t8m/mods_that_make_enemies_have_colored_outlines_that/" target="_blank" rel="noopener noreferrer">Overwatch screenshot</a>  
<a href="https://www.reddit.com/r/gaming/comments/jaodwy/chilling_with_the_enemy_team_in_valorant_after/" target="_blank" rel="noopener noreferrer">VALORANT screenshot</a>  
<a href="https://slurptech.com/make-valorant-vibrant/" target="_blank" rel="noopener noreferrer">VALORANT enemy image</a> 